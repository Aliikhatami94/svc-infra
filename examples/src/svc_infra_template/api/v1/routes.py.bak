"""Enhanced API routes (v1) showcasing svc-infra features.

Note: CRUD endpoints for Project and Task models are auto-generated by svc-infra
at /_sql/projects and /_sql/tasks. See main.py for SqlResource configuration.
"""

from datetime import datetime

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from svc_infra_template.db.models import Project, Task
from svc_infra_template.settings import settings

from svc_infra.api.fastapi.db.sql.session import SqlSessionDep
from svc_infra.api.fastapi.dual.public import public_router

# Create the main router
router = public_router()



@router.get("/ping")
async def ping():
    """Health check endpoint."""
    return {
        "message": "pong",
        "service": "svc-infra-template",
        "version": "0.2.0",
    }


@router.get("/status")
async def status():
    """Detailed status endpoint with feature information."""
    return {
        "status": "healthy",
        "service": "svc-infra-template",
        "version": "0.2.0",
        "environment": settings.app_env,
        "features": {
            "database": settings.database_configured,
            "cache": settings.cache_configured,
            "metrics": settings.metrics_enabled,
            "webhooks": settings.webhooks_enabled,
            "payments": settings.payment_provider,
            "rate_limiting": settings.rate_limit_enabled,
            "idempotency": settings.idempotency_enabled,
        },
    }


@router.get("/features")
async def list_features():
    """List all available features and their configuration."""
    return {
        "service": "svc-infra-template",
        "version": "0.2.0",
        "features": {
            "core": {
                "versioned_api": True,
                "health_checks": True,
                "request_id": True,
                "exception_handling": True,
            },
            "database": {
                "enabled": settings.database_configured,
            },
            "cache": {
                "enabled": settings.cache_configured,
            },
            "observability": {
                "metrics": settings.metrics_enabled,
                "metrics_path": settings.metrics_path if settings.metrics_enabled else None,
            },
            "security": {
                "rate_limiting": settings.rate_limit_enabled,
                "idempotency": settings.idempotency_enabled,
                "cors": settings.cors_enabled,
            },
            "integrations": {
                "payments": settings.payment_provider,
                "webhooks": settings.webhooks_enabled,
            },
            "operations": {
                "maintenance_mode": settings.maintenance_mode,
                "admin": settings.admin_enabled,
                "jobs": settings.jobs_enabled,
            },
        },
        "documentation": {
            "openapi": "/openapi.json",
            "swagger_ui": "/docs",
            "redoc": "/redoc",
        },
    }


# =============================================================================
# Statistics & Aggregations
# Custom endpoint demonstrating complex queries
# =============================================================================


@router.get(
    """Create a new project."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    db_project = Project(
        name=project.name,
        description=project.description,
        owner_email=project.owner_email,
        is_active=project.is_active,
    )
    session.add(db_project)
    await session.commit()
    await session.refresh(db_project)

    return ProjectResponse.model_validate(db_project)


@router.get(
    "/projects",
    response_model=list[ProjectResponse],
    summary="List all projects",
    description="Get a paginated list of all projects (excluding soft-deleted)",
)
async def list_projects(
    session: AsyncSession = SqlSessionDep,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(10, ge=1, le=100, description="Maximum number of records to return"),
    include_inactive: bool = Query(False, description="Include inactive projects"),
):
    """List all projects with pagination."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    # Build query
    query = select(Project).where(Project.deleted_at.is_(None))

    if not include_inactive:
        query = query.where(Project.is_active.is_(True))

    query = query.offset(skip).limit(limit).order_by(Project.created_at.desc())

    result = await session.execute(query)
    projects = result.scalars().all()

    return [ProjectResponse.model_validate(p) for p in projects]


@router.get(
    "/projects/{project_id}",
    response_model=ProjectResponse,
    summary="Get a project by ID",
    description="Retrieve a single project by its ID",
)
async def get_project(
    project_id: int,
    session: AsyncSession = SqlSessionDep,
):
    """Get a project by ID."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(
        select(Project).where(Project.id == project_id, Project.deleted_at.is_(None))
    )
    project = result.scalar_one_or_none()

    if not project:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found",
        )

    return ProjectResponse.model_validate(project)


@router.patch(
    "/projects/{project_id}",
    response_model=ProjectResponse,
    summary="Update a project",
    description="Update project fields (partial update)",
)
async def update_project(
    project_id: int,
    project_update: ProjectUpdate = Body(...),
    session: AsyncSession = SqlSessionDep,
):
    """Update a project."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(
        select(Project).where(Project.id == project_id, Project.deleted_at.is_(None))
    )
    project = result.scalar_one_or_none()

    if not project:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found",
        )

    # Update only provided fields
    update_data = project_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(project, field, value)

    await session.commit()
    await session.refresh(project)

    return ProjectResponse.model_validate(project)


@router.delete(
    "/projects/{project_id}",
    status_code=http_status.HTTP_204_NO_CONTENT,
    summary="Soft-delete a project",
    description="Soft-delete a project (sets deleted_at timestamp)",
)
async def delete_project(
    project_id: int,
    session: AsyncSession = SqlSessionDep,
):
    """Soft-delete a project."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(
        select(Project).where(Project.id == project_id, Project.deleted_at.is_(None))
    )
    project = result.scalar_one_or_none()

    if not project:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Project {project_id} not found",
        )

    # Soft delete
    project.deleted_at = datetime.utcnow()
    await session.commit()


# =============================================================================
# Task CRUD Operations
# Demonstrates: Related entities, status management
# =============================================================================


@router.post(
    "/tasks",
    response_model=TaskResponse,
    status_code=http_status.HTTP_201_CREATED,
    summary="Create a new task",
    description="Create a new task with title, description, and optional project assignment",
)
async def create_task(
    task: TaskCreate = Body(...),
    session: AsyncSession = SqlSessionDep,
):
    """Create a new task."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    # Validate project_id if provided
    if task.project_id:
        result = await session.execute(
            select(Project).where(Project.id == task.project_id, Project.deleted_at.is_(None))
        )
        project = result.scalar_one_or_none()
        if not project:
            raise HTTPException(
                status_code=http_status.HTTP_404_NOT_FOUND,
                detail=f"Project {task.project_id} not found",
            )

    db_task = Task(
        title=task.title,
        description=task.description,
        status=task.status,
        project_id=task.project_id,
        assigned_to=task.assigned_to,
    )
    session.add(db_task)
    await session.commit()
    await session.refresh(db_task)

    return TaskResponse.model_validate(db_task)


@router.get(
    "/tasks",
    response_model=list[TaskResponse],
    summary="List all tasks",
    description="Get a paginated list of all tasks with optional filtering",
)
async def list_tasks(
    session: AsyncSession = SqlSessionDep,
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(10, ge=1, le=100, description="Maximum number of records to return"),
    status_filter: Optional[str] = Query(None, description="Filter by status"),
    project_id: Optional[int] = Query(None, description="Filter by project ID"),
):
    """List all tasks with optional filters."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    # Build query with filters
    query = select(Task)

    if status_filter:
        query = query.where(Task.status == status_filter)

    if project_id is not None:
        query = query.where(Task.project_id == project_id)

    query = query.offset(skip).limit(limit).order_by(Task.created_at.desc())

    result = await session.execute(query)
    tasks = result.scalars().all()

    return [TaskResponse.model_validate(t) for t in tasks]


@router.get(
    "/tasks/{task_id}",
    response_model=TaskResponse,
    summary="Get a task by ID",
    description="Retrieve a single task by its ID",
)
async def get_task(
    task_id: int,
    session: AsyncSession = SqlSessionDep,
):
    """Get a task by ID."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Task {task_id} not found",
        )

    return TaskResponse.model_validate(task)


@router.patch(
    "/tasks/{task_id}",
    response_model=TaskResponse,
    summary="Update a task",
    description="Update task fields (partial update)",
)
async def update_task(
    task_id: int,
    task_update: TaskUpdate = Body(...),
    session: AsyncSession = SqlSessionDep,
):
    """Update a task."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Task {task_id} not found",
        )

    # Update only provided fields
    update_data = task_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(task, field, value)

    # Auto-set completed_at when status changes to completed
    if "status" in update_data and update_data["status"] == "completed" and not task.completed_at:
        task.completed_at = datetime.utcnow()
    elif "status" in update_data and update_data["status"] != "completed":
        task.completed_at = None

    await session.commit()
    await session.refresh(task)

    return TaskResponse.model_validate(task)


@router.delete(
    "/tasks/{task_id}",
    status_code=http_status.HTTP_204_NO_CONTENT,
    summary="Delete a task",
    description="Permanently delete a task",
)
async def delete_task(
    task_id: int,
    session: AsyncSession = SqlSessionDep,
):
    """Delete a task."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    result = await session.execute(select(Task).where(Task.id == task_id))
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(
            status_code=http_status.HTTP_404_NOT_FOUND,
            detail=f"Task {task_id} not found",
        )

    await session.delete(task)
    await session.commit()


# =============================================================================
# Statistics & Aggregations
# Demonstrates: Complex queries, aggregations
# =============================================================================


@router.get(
    "/stats/summary",
    summary="Get statistics summary",
    description="Get overall statistics about projects and tasks",
)
async def get_stats_summary(session: AsyncSession = SqlSessionDep):
    """Get statistics summary."""
    if not settings.database_configured:
        raise HTTPException(
            status_code=http_status.HTTP_501_NOT_IMPLEMENTED,
            detail="Database is not configured. Set SQL_URL in .env to enable.",
        )

    # Count active projects
    projects_result = await session.execute(
        select(Project).where(Project.deleted_at.is_(None), Project.is_active.is_(True))
    )
    active_projects = len(projects_result.scalars().all())

    # Count tasks by status
    tasks_result = await session.execute(select(Task))
    all_tasks = tasks_result.scalars().all()

    task_stats = {
        "total": len(all_tasks),
        "pending": sum(1 for t in all_tasks if t.status == "pending"),
        "in_progress": sum(1 for t in all_tasks if t.status == "in_progress"),
        "completed": sum(1 for t in all_tasks if t.status == "completed"),
        "cancelled": sum(1 for t in all_tasks if t.status == "cancelled"),
    }

    return {
        "projects": {
            "active": active_projects,
        },
        "tasks": task_stats,
        "timestamp": datetime.utcnow().isoformat(),
    }
